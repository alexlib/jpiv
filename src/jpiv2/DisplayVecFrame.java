/*
 * DisplayFrame.java
 *
 * Copyright 2008 Peter Vennemann
 * 
 * This file is part of JPIV.
 *
 * JPIV is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JPIV is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JPIV.  If not, see <http://www.gnu.org/licenses/>. 
 */

package jpiv2;

import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.text.DecimalFormat;

/**
 * Displays a vector field. This class is written to display vectors that are
 * defined in the first four, space separated columns of an UTF-8 file (@see
 * jpiv2.PivData). The cartesian coordinates are defined as follows: Zero is the
 * upper left corner. Positive x goes horizontally to the right, positive y
 * vertically down. <br>
 * First column: x position <br>
 * Second column: y position <br>
 * Third column: x displacement <br>
 * Forth column: y displacement <br>
 * Other columns are ignored.
 * 
 */
public class DisplayVecFrame extends javax.swing.JFrame {

	private jpiv2.JPiv jpiv;
	private String theDataFile;
	private jpiv2.DisplayPanel displayPanel;
	private jpiv2.VecImg vecImg;
	// used for drawing profile lines
	private static final int NONE = 0, PROFILE = 1;
	private int mode = NONE;
	private int x1, y1, x2, y2;
	private Shape newShape;
	private boolean shapeCreated = true;

	/**
	 * Constructor.
	 * 
	 * @param jpiv
	 *            The parent component.
	 * @param filename
	 *            The complete pathname of the UTF-8 file.
	 */
	public DisplayVecFrame(jpiv2.JPiv jpiv, String filename) {
		this.jpiv = jpiv;
		this.theDataFile = filename;
		this.vecImg = new jpiv2.VecImg(jpiv, filename);
		initComponents();
		initDisplayPanel();
		this.setTitle(vecImg.getFilename());
		this.setVisible(true);
		this.pack();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
	// desc=" Generated Code ">//GEN-BEGIN:initComponents
	private void initComponents() {
		jPopupMenu = new javax.swing.JPopupMenu();
		jMenuItemStatistics = new javax.swing.JMenuItem();
		jMenuItemExportAsImg = new javax.swing.JMenuItem();
		jMenuItemExportAsVectorGraphics = new javax.swing.JMenuItem();
		jMenuItemDrawProfileLine = new javax.swing.JMenuItem();
		jLabelStatus = new javax.swing.JLabel();
		jScrollPane = new javax.swing.JScrollPane();

		jMenuItemStatistics.setText("print global statistics");
		jMenuItemStatistics
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						jMenuItemStatisticsActionPerformed(evt);
					}
				});

		jPopupMenu.add(jMenuItemStatistics);

		jMenuItemExportAsImg.setText("export as pixel image");
		jMenuItemExportAsImg
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						jMenuItemExportAsImgActionPerformed(evt);
					}
				});

		jPopupMenu.add(jMenuItemExportAsImg);

		jMenuItemExportAsVectorGraphics.setText("export as vector graphics");
		jMenuItemExportAsVectorGraphics
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						jMenuItemExportAsVectorGraphicsActionPerformed(evt);
					}
				});

		jPopupMenu.add(jMenuItemExportAsVectorGraphics);

		jMenuItemDrawProfileLine.setText("draw profile line");
		jMenuItemDrawProfileLine
				.addActionListener(new java.awt.event.ActionListener() {
					public void actionPerformed(java.awt.event.ActionEvent evt) {
						jMenuItemDrawProfileLineActionPerformed(evt);
					}
				});

		jPopupMenu.add(jMenuItemDrawProfileLine);

		addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent evt) {
				exitForm(evt);
			}
		});

		jLabelStatus.setText("--");
		getContentPane().add(jLabelStatus, java.awt.BorderLayout.SOUTH);

		jScrollPane
				.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
		jScrollPane
				.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		getContentPane().add(jScrollPane, java.awt.BorderLayout.CENTER);

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void jMenuItemExportAsVectorGraphicsActionPerformed(
			java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemExportAsVectorGraphicsActionPerformed
		vecImg.setShapeList(displayPanel.getShapeList());
		String filename;
		String filetype;
		jpiv2.FlexFileChooser flexFileChooser = jpiv.getFlexFileChooser();
		flexFileChooser.setFiletype(FlexFileChooser.GRA_WRITE, false);
		int approve = flexFileChooser.showSaveDialog(this);
		if (approve == javax.swing.JFileChooser.APPROVE_OPTION) {
			filename = flexFileChooser.getSelectedFile().toString();
			filetype = flexFileChooser.getSelectedFiletype();
			vecImg.drawIntoVectorGraphicsFile(filename, filetype);
		}
	}// GEN-LAST:event_jMenuItemExportAsVectorGraphicsActionPerformed

	private void jMenuItemDrawProfileLineActionPerformed(
			java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemDrawProfileLineActionPerformed
		mode = PROFILE;
	}// GEN-LAST:event_jMenuItemDrawProfileLineActionPerformed

	private void jMenuItemExportAsImgActionPerformed(
			java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemExportAsImgActionPerformed
		vecImg.setShapeList(displayPanel.getShapeList());
		String filename;
		String filetype;
		jpiv2.FlexFileChooser flexFileChooser = jpiv.getFlexFileChooser();
		flexFileChooser.setFiletype(flexFileChooser.IMG_WRITE, false);
		int approve = flexFileChooser.showSaveDialog(this);
		if (approve == javax.swing.JFileChooser.APPROVE_OPTION) {
			filename = flexFileChooser.getSelectedFile().toString();
			filetype = flexFileChooser.getSelectedFiletype();
			writeVecImgToFile(filetype, filename);
		}
	}// GEN-LAST:event_jMenuItemExportAsImgActionPerformed

	private void jMenuItemStatisticsActionPerformed(
			java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemStatisticsActionPerformed
		printGlobalStatistics();
	}// GEN-LAST:event_jMenuItemStatisticsActionPerformed

	private void displayPanelMousePopupTrigger(java.awt.event.MouseEvent evt) {
		if (evt.isPopupTrigger()) {
			jPopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
		}
	}

	/**
	 * Writes a string into the status line of the window.
	 * 
	 * @param txt
	 *            The string.
	 */
	public void setStatusText(String txt) {
		jLabelStatus.setText(txt);
	}

	/**
	 * Draws a velocity profile between the specified points. Velocity profiles
	 * are usually drawn via the context menu. The two points are then specified
	 * with the mouse. This method, in contrast, is intended for use in scripts.
	 * This method is not called, during the interactive creation of profiles.
	 * 
	 * @param x1data
	 *            Horizontal position of first point.
	 * @param y1data
	 *            Vertical position of first point.
	 * @param x2data
	 *            Horizontal position of second point.
	 * @param y2data
	 *            Vertical position of second point.
	 */
	public void drawProfile(int x1data, int y1data, int x2data, int y2data) {
		float zoom = jpiv.getSettings().vectorZoom;
		float xOffset = jpiv.getSettings().vectorXOffset;
		float yOffset = jpiv.getSettings().vectorYOffset;
		x1 = Math.round(x1data * zoom + xOffset);
		y1 = Math.round(y1data * zoom + yOffset);
		x2 = Math.round(x2data * zoom + xOffset);
		y2 = Math.round(y2data * zoom + yOffset);
		interpolateProfile();
		repaint();
	}

	/**
	 * Writes the image as displayed to a file. This method is rather slow, but
	 * also exports profiles. You can also export the data directly using the
	 * getAsPlanarImage() method from the class VecImg. You can not export
	 * profiles then, however.
	 * 
	 * @param filetype
	 *            File extension like png, tiff, jpeg etc.
	 * @param filename
	 *            Name of the file.
	 */
	public void writeVecImgToFile(String filetype, String filename) {
		displayPanel.writeVecImgToFile(filetype, filename);
	}

	private void displayPanelMouseMoved(java.awt.event.MouseEvent evt) {
		int x = evt.getX();
		int y = evt.getY();
		double[] v = vecImg.getVectorAt(x, y);
		if (v != null) {
			setStatusText(" x: " + v[0] + " y: " + v[1] + " ux: " + v[2]
					+ " uy: " + v[3] + " flag: " + v[4] + " u: "
					+ Math.sqrt(v[2] * v[2] + v[3] * v[3]));
		} else
			setStatusText("--");
	}

	private void initDisplayPanel() {
		displayPanel = new jpiv2.DisplayPanel(jpiv, vecImg.getAsPlanarImage(),
				2);
		displayPanel
				.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
					public void mouseMoved(java.awt.event.MouseEvent evt) {
						displayPanelMouseMoved(evt);
					}
				});
		displayPanel.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt) {
				displayPanelMousePopupTrigger(evt);
			}

			public void mousePressed(java.awt.event.MouseEvent evt) {
				if (mode == PROFILE) {
					// store initial mouse position for drawing a line
					x1 = evt.getX();
					y1 = evt.getY();
					shapeCreated = false;
				} else {
					displayPanelMousePopupTrigger(evt);
				}
			}

			public void mouseReleased(java.awt.event.MouseEvent evt) {
				if (mode == PROFILE) {
					interpolateProfile();
					mode = NONE;
					repaint();
				} else {
					displayPanelMousePopupTrigger(evt);
				}
			}
		});
		displayPanel
				.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
					public void mouseDragged(java.awt.event.MouseEvent evt) {
						if (mode == PROFILE) {
							// store current mouse position for end point of
							// line
							x2 = evt.getX();
							y2 = evt.getY();
							if (!shapeCreated) {
								// create line
								newShape = new Line2D.Double(x1, y1, x2, y2);
								displayPanel.addShape(newShape);
								shapeCreated = true;
							} else {
								// move line
								((Line2D) newShape).setLine(x1, y1, x2, y2);
							}
							repaint();
						}
					}
				});
		jScrollPane.setViewportView(displayPanel);
	}

	/**
	 * Print vector statistics. Prints some statistics like the mean, median,
	 * min, max and standard deviation of the vector field and its components to
	 * the standard output channel.
	 */
	public void printGlobalStatistics() {
		String statistics = new String();
		jpiv2.PivData pivData = vecImg.getPivData();
		// ux
		double uxmean = jpiv2.Statistics.getAverage(pivData.getDataColumn(2));
		double uxmedian = jpiv2.Statistics.getMedian(pivData.getDataColumn(2));
		double uxmin = jpiv2.Statistics.getMin(pivData.getDataColumn(2));
		double uxmax = jpiv2.Statistics.getMax(pivData.getDataColumn(2));
		double uxstdev = jpiv2.Statistics.getStandardDeviation(pivData
				.getDataColumn(2));
		// uy
		double uymean = jpiv2.Statistics.getAverage(pivData.getDataColumn(3));
		double uymedian = jpiv2.Statistics.getMedian(pivData.getDataColumn(3));
		double uymin = jpiv2.Statistics.getMin(pivData.getDataColumn(3));
		double uymax = jpiv2.Statistics.getMax(pivData.getDataColumn(3));
		double uystdev = jpiv2.Statistics.getStandardDeviation(pivData
				.getDataColumn(3));
		// u
		double umean = jpiv2.Statistics.getAverage(pivData.getAbsValue(2, 3));
		double umedian = jpiv2.Statistics.getMedian(pivData.getAbsValue(2, 3));
		double umin = jpiv2.Statistics.getMin(pivData.getAbsValue(2, 3));
		double umax = jpiv2.Statistics.getMax(pivData.getAbsValue(2, 3));
		double ustdev = jpiv2.Statistics.getStandardDeviation(pivData
				.getAbsValue(2, 3));
		// printing the velocity statistics
		java.text.DecimalFormat df = new java.text.DecimalFormat(
				"+0.0000E00;-0.0000E00");
		System.out.println("\nGlobal statistics of " + vecImg.getFilename());
		System.out.println("\tmean\tmedian\tmin\tmax\tstdev");
		System.out.println("ux\t" + df.format(uxmean) + "\t"
				+ df.format(uxmedian) + "\t" + df.format(uxmin) + "\t"
				+ df.format(uxmax) + "\t" + df.format(uxstdev) + "\t");
		System.out.println("uy\t" + df.format(uymean) + "\t"
				+ df.format(uymedian) + "\t" + df.format(uymin) + "\t"
				+ df.format(uymax) + "\t" + df.format(uystdev) + "\t");
		System.out.println("u\t" + df.format(umean) + "\t" + df.format(umedian)
				+ "\t" + df.format(umin) + "\t" + df.format(umax) + "\t"
				+ df.format(ustdev) + "\t");
		// flags
		int col = pivData.getNumOfColumns();
		for (int i = 4; i < col; i++) {
			System.out.println("flag "
					+ (i - 3)
					+ "\t"
					+ df.format(jpiv2.Statistics.getAverage(pivData
							.getDataColumn(i)))
					+ "\t"
					+ df.format(jpiv2.Statistics.getMedian(pivData
							.getDataColumn(i)))
					+ "\t"
					+ df.format(jpiv2.Statistics.getMin(pivData
							.getDataColumn(i)))
					+ "\t"
					+ df.format(jpiv2.Statistics.getMax(pivData
							.getDataColumn(i)))
					+ "\t"
					+ df.format(jpiv2.Statistics.getStandardDeviation(pivData
							.getDataColumn(i))) + "\t");
		}
	}

	private void interpolateProfile() {
		jpiv2.PivData theData = new jpiv2.PivData(theDataFile);
		float zoom = jpiv.getSettings().vectorZoom;
		float scale = jpiv.getSettings().vectorScale;
		float xOffset = jpiv.getSettings().vectorXOffset;
		float yOffset = jpiv.getSettings().vectorYOffset;
		int numberOf = 1;
		int distance = 0;
		if (jpiv.getSettings().profileAverage) {
			numberOf = jpiv.getSettings().profileNumberOf;
			distance = jpiv.getSettings().profileDistance;
		}
		float x1data = (x1 - xOffset) / zoom;
		float y1data = (y1 - yOffset) / zoom;
		float x2data = (x2 - xOffset) / zoom;
		float y2data = (y2 - yOffset) / zoom;
		float spacing = 0;
		if (jpiv.getSettings().profileFixDataPoints) {
			int numOfPoints = jpiv.getSettings().profileNumOfFixDataPoints;
			spacing = (float) Math.sqrt((x2data - x1data) * (x2data - x1data)
					+ (y2data - y1data) * (y2data - y1data))
					/ (numOfPoints - 1);
		}
		double[][][] theProfiles = theData.getFreeProfiles(x1data, y1data,
				x2data, y2data, spacing, numberOf, distance);
		// draw all profiles
		for (int p = 0; p < theProfiles.length - 1; p++) {
			double[][] theProfile = theProfiles[p];
			// create polygone
			int[] xPoints = new int[theProfile.length + 2];
			int[] yPoints = new int[theProfile.length + 2];
			// first point
			xPoints[0] = Math.round(Math.round(theProfile[0][0] * zoom
					+ xOffset));
			yPoints[0] = Math.round(Math.round(theProfile[0][1] * zoom
					+ yOffset));
			// last point
			xPoints[xPoints.length - 1] = Math.round(Math
					.round(theProfile[theProfile.length - 1][0] * zoom
							+ xOffset));
			yPoints[xPoints.length - 1] = Math.round(Math
					.round(theProfile[theProfile.length - 1][1] * zoom
							+ yOffset));
			// rest
			for (int i = 1; i < (xPoints.length - 1); i++) {
				xPoints[i] = Math.round(Math.round(theProfile[i - 1][0] * zoom
						+ xOffset + theProfile[i - 1][2] * scale));
			}
			for (int i = 1; i < (yPoints.length - 1); i++) {
				yPoints[i] = Math.round(Math.round(theProfile[i - 1][1] * zoom
						+ yOffset + theProfile[i - 1][3] * scale));
			}
			GeneralPath polygone = new GeneralPath(GeneralPath.WIND_EVEN_ODD,
					xPoints.length);
			polygone.moveTo(xPoints[0], yPoints[0]);
			// no interpolation
			if (jpiv.getSettings().profileQuadInterp == false) {
				for (int i = 1; i < xPoints.length; i++) {
					polygone.lineTo(xPoints[i], yPoints[i]);
				}
			}
			// quadratic interpolation
			else {
				int[] xPointsInterp = new int[xPoints.length];
				int[] yPointsInterp = new int[yPoints.length];
				int[] xPointsCtrl = new int[xPoints.length - 1];
				int[] yPointsCtrl = new int[yPoints.length - 1];
				// control points of bezier splines
				for (int i = 0; i < xPointsCtrl.length; i++) {
					xPointsCtrl[i] = xPoints[i]
							+ Math.round((xPoints[i + 1] - xPoints[i]) / 2f);
					yPointsCtrl[i] = yPoints[i]
							+ Math.round((yPoints[i + 1] - yPoints[i]) / 2f);
				}
				// end points of bezier splines
				xPointsInterp[0] = xPoints[0];
				yPointsInterp[0] = yPoints[0];
				xPointsInterp[xPointsInterp.length - 1] = xPoints[xPoints.length - 1];
				yPointsInterp[yPointsInterp.length - 1] = yPoints[yPoints.length - 1];
				for (int i = 1; i < xPointsInterp.length - 1; i++) {
					xPointsInterp[i] = xPointsCtrl[i - 1]
							+ Math.round((xPointsCtrl[i] - xPointsCtrl[i - 1]) / 2f);
					yPointsInterp[i] = yPointsCtrl[i - 1]
							+ Math.round((yPointsCtrl[i] - yPointsCtrl[i - 1]) / 2f);
				}
				// drawing
				for (int i = 1; i < xPointsInterp.length; i++) {
					polygone.quadTo(xPointsCtrl[i - 1], yPointsCtrl[i - 1],
							xPointsInterp[i], yPointsInterp[i]);
				}
			}
			polygone.closePath();
			// add the profile to the display panel:
			displayPanel.addShape(polygone);
			// print some statistics
			if (jpiv.getSettings().profilePrintStat == true) {
				double length = Math.sqrt((x2data - x1data) * (x2data - x1data)
						+ (y2data - y1data) * (y2data - y1data));
				double area = 0;
				for (int i = 0; i < (xPoints.length - 1); i++) {
					area += (xPoints[i] - xPoints[i + 1])
							* (yPoints[i] + yPoints[i + 1]);
				}
				area += (xPoints[xPoints.length - 1] - xPoints[0])
						* (yPoints[xPoints.length - 1] + yPoints[0]);
				area = area / 2 / scale / (zoom * zoom);
				DecimalFormat df = new DecimalFormat("#0.00");
				System.out.println("profile statistics");
				System.out.println("x1: " + x1data + " y1: " + y1data + " x2: "
						+ x2data + " y2: " + y2data);
				System.out.println("length:\t" + df.format(length)
						+ "\tpixel (not scaled)");
				System.out.println("area:\t" + df.format(area)
						+ "\tsquare-pixel (not scaled)");
			}
			// print profile data
			if (jpiv.getSettings().profilePrintData == true) {
				System.out.println("profile data");
				System.out
						.println("x [pixel]\ty [pixel]\tdx [pixel]\tdy [pixel]\t");
				DecimalFormat df = new DecimalFormat("+0.0000E00;-0.0000E00");
				for (int i = 0; i < theProfile.length; i++) {
					System.out.println(df.format(theProfile[i][0]) + "\t"
							+ df.format(theProfile[i][1]) + "\t"
							+ df.format(theProfile[i][2]) + "\t"
							+ df.format(theProfile[i][3]) + "\t");
				}
			}
			// print data of average profile
			if (jpiv.getSettings().profileAverage == true
					&& jpiv.getSettings().profilePrintData == true
					&& p == theProfiles.length - 2) {
				System.out.println("average of previous profiles");
				System.out
						.println("x [pixel]\ty [pixel]\tdx [pixel]\tdy [pixel]\t");
				DecimalFormat df = new DecimalFormat("+0.0000E00;-0.0000E00");
				for (int i = 0; i < theProfile.length; i++) {
					System.out.println(df.format(theProfile[i][0]) + "\t"
							+ df.format(theProfile[i][1]) + "\t"
							+ df.format(theProfile[i][2]) + "\t"
							+ df.format(theProfile[i][3]) + "\t");
				}
			}
		}
	}

	/** Close the Frame. */
	private void exitForm(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_exitForm
		this.dispose();
	}// GEN-LAST:event_exitForm

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JLabel jLabelStatus;
	private javax.swing.JMenuItem jMenuItemDrawProfileLine;
	private javax.swing.JMenuItem jMenuItemExportAsImg;
	private javax.swing.JMenuItem jMenuItemExportAsVectorGraphics;
	private javax.swing.JMenuItem jMenuItemStatistics;
	private javax.swing.JPopupMenu jPopupMenu;
	private javax.swing.JScrollPane jScrollPane;
	// End of variables declaration//GEN-END:variables

}
